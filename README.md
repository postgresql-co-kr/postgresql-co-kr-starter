# 이상적인 구조와 현실 사이에서

문서나 컨퍼런스에서 소개되는 프로젝트 구조는 언제나 깔끔합니다. `apps / modules / common`처럼 명확히 나뉜 계층, 단방향 의존성, 일관된 빌드 전략. 보고 있으면 “이렇게만 하면 되겠네”라는 생각이 들죠.

하지만 현실의 프로젝트는 거의 그렇지 않습니다.

SI 프로젝트라면 그나마 사정이 나은 편입니다. AA(아키텍트)가 주도해 “이렇게 갑니다”라고 방향을 잡으면, 중간중간 반발은 있어도 일정과 권한이라는 힘으로 어느 정도는 정리됩니다.

문제는 업무 유지보수나 사내 프로젝트입니다.

- “왜 이렇게까지 복잡해야 하나요?”
- “지금도 잘 돌아가는데 굳이 바꿔야 하나요?”
- “나는 이클립스를 쓰는데, 이 구조는 불편해요.”
- “Gradle 멀티 모듈은 디버깅이 어려워요.”
- “이거, 나 말고 유지보수할 사람 있나요?”

어느 하나 틀린 말은 없습니다. 그리고 이 질문들의 출발점은 대부분 기술이 아니라 **사람**입니다.

이미 운영 중인 코드가 있고, 각자 익숙한 방식이 있으며, 바쁜 일정 속에서 “지금 당장 동작하는 것”이 최우선인 환경에서 아키텍처는 종종 사치처럼 보이기도 합니다.

그래서 많은 프로젝트가 이렇게 시작합니다.

> “일단 하나로 만들고, 나중에 나누죠.”

그리고 그 “나중”은 거의 오지 않습니다.

---

이 문서는 완벽한 이상론을 강요하기 위한 문서가 아닙니다. 또한 “이게 정답이다”라고 단정하려는 문서도 아닙니다.

대신 다음을 설명하려고 합니다.

- 왜 이런 구조가 필요해지는지
- 어떤 시점에서 한계를 맞게 되는지
- 그리고 현실적인 타협선은 어디쯤인지

처음부터 MSA를 하자는 이야기도 아니고, 처음부터 모든 것을 분리하자는 주장도 아닙니다.

다만,

> 지금은 하나의 JAR이지만, 언젠가는 갈라질 수 있는 방향으로 시작하자

라는 최소한의 합의를 만들기 위한 구조를 이야기합니다.

---

# Spring Boot 4 기반 모던 백엔드 아키텍처 및 프로젝트 구성 가이드

이 프로젝트는 **postgresql.co.kr 커뮤니티**를 위한 **Modern Spring Boot 4 & Java 25** 기반 백엔드 스타터 킷입니다.

엔터프라이즈 환경에서 검증된 아키텍처와 최신 기술 스택을 미리 구성해 두어, 복잡한 설정에 시간을 쓰기보다 비즈니스 로직에 바로 집중할 수 있도록 설계되었습니다.

[English](README.en.md)

---

## 1. 기술 스택 분석 (Why This Stack?)

이 프로젝트에 포함된 라이브러리들은 단순히 최신이라는 이유로 선택된 것이 아닙니다. 실제 운영 환경에서 **생산성, 타입 안정성, 성능**을 균형 있게 확보하기 위한 조합입니다.

### 1.1 Core Components

| 라이브러리       | 버전    | 선정 이유                                                             |
| ----------- | ----- | ----------------------------------------------------------------- |
| Spring Boot | 4.0.1 | Jakarta EE 11, Java 25 지원. Virtual Threads와 GraalVM을 전제로 한 차세대 표준 |
| Java        | 25    | Project Loom 성숙 단계. 최신 언어 기능과 성능을 동시에 확보                          |
| Gradle      | 8.x+  | 빠른 빌드 속도와 캐싱 전략을 제공하는 멀티 모듈 표준                                    |

### 1.2 Data & Architecture

| 라이브러리         | 역할       | 선정 이유                          |
| ------------- | -------- | ------------------------------ |
| QueryDSL 5.1  | 타입 안전 쿼리 | 동적 쿼리를 코드로 표현해 컴파일 시점에 오류를 발견  |
| MapStruct 1.6 | DTO 매핑   | 런타임 리플렉션 없이 컴파일 타임 코드 생성       |
| UUID v7       | ID 전략    | 시간 정렬 기반 UUID로 DB 인덱스 성능 저하 방지 |

### 1.3 AI & Cloud

| 라이브러리         | 역할    | 선정 이유                        |
| ------------- | ----- | ---------------------------- |
| Spring AI 2.0 | AI 통합 | LLM 벤더 종속을 피하기 위한 표준 추상화 계층  |
| AWS SDK v2    | 클라우드  | Non-blocking I/O와 낮은 메모리 사용량 |

---

## 2. 모노레포 명명 표준 및 아키텍처

이 구조의 목적은 단순히 프로젝트를 나누는 것이 아니라, **역할과 의존성의 방향을 코드 레벨에서 드러내는 것**입니다.

### 2.1 표준 디렉터리 구조

| 폴더      | 역할          | 설명                                |
| ------- | ----------- | --------------------------------- |
| apps    | Application | 실행·배포 단위. modules를 조립해 애플리케이션을 구성 |
| modules | Feature     | 실제 비즈니스 도메인 로직이 위치                |
| common  | Shared      | 비즈니스와 무관한 공통 기술 영역                |

### 2.2 의존성 규칙

1. `apps → modules → common` 단방향 의존성
2. modules 간 참조는 최소화하며 순환 의존성 금지
3. common은 상위 계층을 절대 알지 못함

이 규칙이 깨지는 순간, 구조는 빠르게 무너지기 시작합니다.

---

## 3. 프로젝트 구성과 코드의 의미

이 섹션은 개별 설정을 설명하기 위한 부분이 아닙니다. **코드와 설정이 구조를 어떻게 강제하고, 어디까지 통제하는지를 읽는 방법**에 집중합니다.

---

### 3.1 Gradle Wrapper

```bash
gradle wrapper
./gradlew clean build
```

이 프로젝트에서 Wrapper는 선택지가 아닙니다. 모든 빌드와 실행은 **이 저장소가 정의한 Gradle 버전**을 기준으로만 이루어진다는 전제를 깔고 시작합니다.

Wrapper가 없는 상태에서 멀티 모듈 구조가 커지면 다음 문제가 반드시 발생합니다.

- 로컬과 CI의 Gradle 버전 차이
- 플러그인 DSL 동작 불일치
- 특정 버전에서만 재현되는 빌드 오류

Wrapper는 이 모든 변수를 제거합니다. 이후 발생하는 빌드 문제는 더 이상 환경 문제가 아니라 **설계 또는 코드 문제**로 수렴됩니다.

즉, Wrapper의 목적은 편의가 아니라 **빌드 책임 소재를 명확히 하는 것**입니다.

---

### 3.2 settings.gradle

```groovy
rootProject.name = 'postgresql-co-kr-starter'

include 'apps:api'
include 'modules:user'
include 'common:core'
```

`settings.gradle`은 구조 선언부입니다. 여기에 포함된 모듈은 모두 **장기적으로 유지보수할 의지가 있는 코드**라는 의미를 가집니다.

이 파일에서 중요한 것은 *무엇을 포함했는가*보다 **무엇을 아직 포함하지 않았는가**입니다.

- 실험용 코드
- 방향이 불분명한 기능
- 일시적인 대응 로직

이런 요소들이 무분별하게 `include`되기 시작하면, 모노레포의 경계는 빠르게 흐려집니다.

`settings.gradle`을 보수적으로 관리하면:

- 구조가 문서 역할을 하게 되고
- 모듈 추가 자체가 하나의 의사결정이 되며
- 프로젝트의 성장 방향이 코드로 기록됩니다.

---

### 3.3 Root build.gradle

```groovy
allprojects {
    group = 'kr.co.postgresql'
    version = '0.0.1-SNAPSHOT'
}
```

루트 `build.gradle`은 기능 정의 파일이 아닙니다. 이 프로젝트 전체에 적용되는 **최소한의 공통 규칙만 존재해야 하는 영역**입니다.

여기에 다음과 같은 코드가 들어가기 시작하면 위험 신호입니다.

- 특정 모듈 전용 플러그인 설정
- 비즈니스 의존성 선언
- 환경별 분기 로직

공통 규칙이 많아질수록, 변경 비용은 선형이 아니라 기하급수적으로 증가합니다.

이 구조에서는:

- 루트는 헌법처럼 거의 변하지 않고
- 각 모듈의 `build.gradle`이 실제 정책을 담당합니다.

---

### 3.4 common/core

```groovy
dependencies {
    api 'com.github.f4b6a3:uuid-creator:6.0.0'
}
```

`core`는 모든 의존성 방향의 시작점입니다. 이 모듈은 **아무것에도 의존하지 않는다는 점**이 가장 중요한 특징입니다.

프레임워크가 들어오는 순간, 이 모듈은 더 이상 안전한 기반이 아닙니다.

`core`에 들어갈 수 있는 코드는 명확합니다.

- 순수 유틸리티
- 타입 정의
- 식별자, 규칙, 공통 값 객체

이 경계가 지켜질수록, 상위 구조는 더 오랫동안 안정적으로 유지됩니다.

---

### 3.5 common/infra

```groovy
api 'org.springframework.boot:spring-boot-starter-data-redis'
api 'software.amazon.awssdk:s3'
```

`infra`는 외부 세계와 맞닿아 있는 영역입니다. DB, 캐시, 메시지 브로커, 클라우드 SDK가 이곳에 모입니다.

중요한 점은 **비즈니스 로직이 이 의존성을 직접 알지 않게 하는 것**입니다.

`infra`가 두꺼워질수록 비즈니스 코드는 오히려 가벼워져야 합니다.

#### Java Config 는 어디에 두어야 하는가?

이 구조에서 Java Config의 위치는 **의존성의 방향**으로 판단합니다.

- 외부 기술을 초기화·연결하기 위한 설정이라면 → `common/infra`
- 도메인 규칙을 조합하거나 정책을 결정한다면 → `modules/*`
- 실행 방식, 프로파일, 빈 조합을 선택한다면 → `apps/*`

`infra`에 위치하는 Java Config의 전형적인 예는 다음과 같습니다.

```java
@Configuration
public class RedisConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        return new LettuceConnectionFactory();
    }
}
```

이 설정의 특징은 명확합니다.

- Redis라는 **외부 기술을 알고 있고**
- 비즈니스 의미를 전혀 가지지 않으며
- 다른 모듈에서 구현 세부사항을 알 필요가 없습니다.

따라서 이런 Config는 `infra`가 소유하는 것이 맞습니다.

반대로 다음과 같은 설정은 `infra`에 두면 안 됩니다.

- 특정 도메인 서비스 조합
- 조건부 비즈니스 정책 빈 구성
- 유스케이스 흐름을 결정하는 설정

Java Config는 단순히 "설정 파일"이 아니라, **의존성과 책임의 경계를 코드로 고정하는 수단**입니다.

Config가 잘못된 위치에 놓이면, 의존성 규칙은 순식간에 무너집니다.

---

### 3.6 modules/user

```groovy
api 'org.springframework.boot:spring-boot-starter-data-jpa'
api 'com.querydsl:querydsl-jpa:5.1.0:jakarta'
```

모든 업무 규칙은 이 영역에 존재합니다. 이 모듈이 흔들리면, 프로젝트 전체가 흔들립니다.

QueryDSL을 사용하는 이유는 단순합니다. **실패 시점을 런타임에서 컴파일 타임으로 끌어오기 위함**입니다.

---

### 3.7 apps/api

```groovy
implementation project(':modules:user')
implementation project(':common:infra')
```

`apps`는 결정을 내리는 곳이지, 로직을 작성하는 곳이 아닙니다.

- 어떤 모듈을 묶어 실행할지
- 어떤 프로파일로 배포할지

이 선택만 담당합니다.

`apps`가 비어 있을수록, 구조는 더 오래 살아남습니다.

---

## 4. 결론

이 구조는 이상적인 그림을 강요하지 않습니다. 다만 시간이 지나며 자연스럽게 드러나는 문제를 미리 줄이기 위한 선택입니다.

지금은 하나의 애플리케이션이지만, 언제든 분리될 수 있는 방향으로 출발하는 것.

그것이 이 문서가 전달하고자 하는 핵심입니다.

---

## GitHub

[https://github.com/postgresql-co-kr/postgresql-co-kr-starter/tree/main](https://github.com/postgresql-co-kr/postgresql-co-kr-starter/tree/main)
